/**
 * JavaScript and Node.js SDK for OpenFGA
 *
 * API version: 1.x
 * Website: https://openfga.dev
 * Documentation: https://openfga.dev/docs
 * Support: https://openfga.dev/community
 * License: [Apache-2.0](https://github.com/openfga/js-sdk/blob/main/LICENSE)
 *
 * NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 */


import type { Readable } from "node:stream";
import {
  FgaError,
  FgaApiError,
  FgaApiValidationError,
  FgaApiAuthenticationError,
  FgaApiNotFoundError,
  FgaApiRateLimitExceededError,
  FgaApiInternalError
} from "./errors";
import { calculateExponentialBackoffWithJitter } from "./common";

// Helper: create async iterable from classic EventEmitter-style Readable streams
const createAsyncIterableFromReadable = (readable: any): AsyncIterable<any> => {
  return {
    [Symbol.asyncIterator](): AsyncIterator<any> {
      const chunkQueue: any[] = [];
      const pendingResolvers: Array<(value: IteratorResult<any>) => void> = [];
      let ended = false;
      let error: any = null;

      const onData = (chunk: any) => {
        if (pendingResolvers.length > 0) {
          const resolve = pendingResolvers.shift()!;
          resolve({ value: chunk, done: false });
        } else {
          chunkQueue.push(chunk);
        }
      };

      const onEnd = () => {
        ended = true;
        while (pendingResolvers.length > 0) {
          const resolve = pendingResolvers.shift()!;
          resolve({ value: undefined, done: true });
        }
      };

      const onError = (err: any) => {
        error = err;
        while (pendingResolvers.length > 0) {
          const resolve = pendingResolvers.shift()!;
          // Rejecting inside async iterator isn't straightforward; surface as end and throw later
          resolve({ value: undefined, done: true });
        }
      };

      readable.on("data", onData);
      readable.once("end", onEnd);
      readable.once("error", onError);

      const cleanup = () => {
        readable.off("data", onData);
        readable.off("end", onEnd);
        readable.off("error", onError);
      };

      return {
        next(): Promise<IteratorResult<any>> {
          if (error) {
            cleanup();
            return Promise.reject(error);
          }
          if (chunkQueue.length > 0) {
            const value = chunkQueue.shift();
            return Promise.resolve({ value, done: false });
          }
          if (ended) {
            cleanup();
            return Promise.resolve({ value: undefined, done: true });
          }
          return new Promise<IteratorResult<any>>((resolve) => {
            pendingResolvers.push(resolve);
          });
        },
        return(): Promise<IteratorResult<any>> {
          cleanup();
          return Promise.resolve({ value: undefined, done: true });
        },
        throw(e?: any): Promise<IteratorResult<any>> {
          cleanup();
          return Promise.reject(e);
        }
      };
    }
  };
};

/**
 * Parse newline-delimited JSON (NDJSON) from a Node.js readable stream
 * @param stream - Node.js readable stream
 * @returns AsyncGenerator that yields parsed JSON objects
 */
export async function* parseNDJSONStream(stream: Readable): AsyncGenerator<any> {
  const decoder = new TextDecoder("utf-8");
  let buffer = "";

  // If stream is actually a string or Buffer-like, handle as whole payload
  const isString = typeof (stream as unknown) === "string";
  const isBuffer = typeof Buffer !== "undefined" && Buffer.isBuffer && Buffer.isBuffer(stream as unknown);
  if (isString || isBuffer) {
    const text = isString ? (stream as unknown as string) : new TextDecoder("utf-8").decode(new Uint8Array(stream as unknown as ArrayBufferLike));
    const lines = text.split("\n");
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed) continue;
      try {
        yield JSON.parse(trimmed);
      } catch (err) {
        console.warn("Failed to parse JSON line:", err);
      }
    }
    return;
  }

  const isAsyncIterable = stream && typeof (stream as any)[Symbol.asyncIterator] === "function";
  const source: AsyncIterable<any> = isAsyncIterable ? (stream as any) : createAsyncIterableFromReadable(stream as any);

  for await (const chunk of source) {
    // Node.js streams can return Buffer or string chunks
    // Convert to Uint8Array if needed for TextDecoder
    const uint8Chunk = typeof chunk === "string"
      ? new TextEncoder().encode(chunk)
      : chunk instanceof Buffer
        ? new Uint8Array(chunk)
        : chunk;

    // Append decoded chunk to buffer
    buffer += decoder.decode(uint8Chunk, { stream: true });

    // Split on newlines
    const lines = buffer.split("\n");

    // Keep the last (potentially incomplete) line in the buffer
    buffer = lines.pop() || "";

    // Parse and yield complete lines
    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed) {
        try {
          yield JSON.parse(trimmed);
        } catch (err) {
          console.warn("Failed to parse JSON line:", err);
        }
      }
    }
  }

  // Flush any remaining decoder state
  buffer += decoder.decode();

  // Handle any remaining data in buffer
  if (buffer.trim()) {
    try {
      yield JSON.parse(buffer);
    } catch (err) {
      console.warn("Failed to parse final JSON buffer:", err);
    }
  }
}

/**
 * Parse newline-delimited JSON (NDJSON) from a browser ReadableStream
 * @param stream - Browser ReadableStream (from Fetch API)
 * @returns AsyncGenerator that yields parsed JSON objects
 */
export async function* parseNDJSONReadableStream(stream: ReadableStream<Uint8Array>): AsyncGenerator<any> {
  const reader = stream.getReader();
  const decoder = new TextDecoder("utf-8");
  let buffer = "";

  try {
    while (true) {
      const { done, value } = await reader.read();

      if (done) {
        break;
      }

      // Decode chunk and append to buffer
      buffer += decoder.decode(value, { stream: true });

      // Split on newlines
      const lines = buffer.split("\n");

      // Keep the last (potentially incomplete) line in the buffer
      buffer = lines.pop() || "";

      // Parse and yield complete lines
      for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed) {
          try {
            yield JSON.parse(trimmed);
          } catch (err) {
            // Skip invalid JSON lines
            console.warn("Failed to parse JSON line:", err);
          }
        }
      }
    }

    // Handle any remaining data in buffer
    if (buffer.trim()) {
      try {
        yield JSON.parse(buffer);
      } catch (err) {
        console.warn("Failed to parse final JSON buffer:", err);
      }
    }
  } finally {
    reader.releaseLock();
  }
}

/**
 * Detect if we're running in a Node.js environment
 * @returns true if Node.js, false if browser
 */
export function isNodeEnvironment(): boolean {
  return typeof process === "object" && process.versions?.node !== undefined;
}

/**
 * Create an SDK error from a fetch Response
 * 
 * Note: This function adapts a Fetch API Response to the SDK's AxiosError-based error classes.
 * The SDK error classes expect an AxiosError structure, so we create a compatible object
 * that contains the same fields (response.status, response.data, config.url, etc.).
 * This allows browser fetch requests to use the same error types as axios requests.
 * 
 * @param response - Fetch API Response object
 * @param url - Request URL
 * @param requestBody - Request body
 * @returns Appropriate SDK error based on HTTP status code
 */
export async function createFetchError(response: Response, url: string, requestBody: any): Promise<Error> {
  const status = response.status;
  let errorData: any;

  try {
    errorData = await response.json();
  } catch {
    errorData = { message: response.statusText };
  }

  // Adapt Fetch Response to AxiosError structure for SDK error classes
  // The error classes extract status, data, headers, etc. from this structure
  const axiosErrorAdapter = {
    response: {
      status,
      statusText: response.statusText,
      data: errorData,
      headers: Object.fromEntries(response.headers.entries())
    },
    config: {
      url,
      method: "POST" as const,
      data: JSON.stringify(requestBody)
    },
    request: {
      path: new URL(url).pathname
    },
    isAxiosError: true
  } as any; // Type assertion needed as error constructors expect AxiosError

  // Map HTTP status codes to appropriate SDK error types
  if (status === 400 || status === 422) {
    return new FgaApiValidationError(axiosErrorAdapter);
  } else if (status === 401 || status === 403) {
    return new FgaApiAuthenticationError(axiosErrorAdapter);
  } else if (status === 404) {
    return new FgaApiNotFoundError(axiosErrorAdapter);
  } else if (status === 429) {
    return new FgaApiRateLimitExceededError(axiosErrorAdapter);
  } else if (status >= 500 && status !== 501) {
    return new FgaApiInternalError(axiosErrorAdapter);
  } else {
    return new FgaApiError(axiosErrorAdapter);
  }
}

/**
 * Attempt a fetch request with retry logic
 * @param url - Request URL
 * @param options - Fetch options
 * @param requestBody - Request body
 * @param retryConfig - Retry configuration
 * @returns Response object
 */
export async function attemptFetchRequest(
  url: string,
  options: RequestInit,
  requestBody: any,
  retryConfig: { maxRetry: number; minWaitInMs: number }
): Promise<Response> {
  let iterationCount = 0;
  const { maxRetry, minWaitInMs } = retryConfig;

  do {
    ++iterationCount;

    try {
      const response = await fetch(url, options);

      if (response.ok) {
        return response;
      }

      const status = response.status;
      const isRetryable = status === 429 || (status >= 500 && status !== 501);

      if (isRetryable && iterationCount <= maxRetry) {
        // Use SDK's standard exponential backoff with jitter
        const delayMs = calculateExponentialBackoffWithJitter(iterationCount, minWaitInMs);
        await new Promise(r => setTimeout(r, delayMs));
        continue;
      }

      // Not retryable or out of retries
      throw await createFetchError(response, url, requestBody);
    } catch (err) {
      // If it's already an SDK error, re-throw
      if ((err as any)?.name?.startsWith("FgaApi") || (err as any)?.name === "FgaError") {
        throw err;
      }

      // Network error
      if (iterationCount > maxRetry) {
        throw new FgaError(err);
      }

      // Retry on network error using SDK's standard backoff
      const delayMs = calculateExponentialBackoffWithJitter(iterationCount, minWaitInMs);
      await new Promise(r => setTimeout(r, delayMs));
    }
  } while (iterationCount <= maxRetry);

  // Should never reach here, but TypeScript needs it
  throw new FgaError("Maximum retries exceeded");
}

