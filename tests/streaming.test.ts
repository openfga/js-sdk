/**
 * JavaScript and Node.js SDK for OpenFGA
 *
 * API version: 1.x
 * Website: https://openfga.dev
 * Documentation: https://openfga.dev/docs
 * Support: https://openfga.dev/community
 * License: [Apache-2.0](https://github.com/openfga/js-sdk/blob/main/LICENSE)
 *
 * NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 */


import { Readable } from "node:stream";
import { parseNDJSONStream, parseNDJSONReadableStream, isNodeEnvironment, createFetchError, attemptFetchRequest } from "../streaming";

// Helper to create a mock ReadableStream (used by multiple test suites)
function createMockReadableStream(data: string[]): ReadableStream<Uint8Array> {
    const encoder = new TextEncoder();
    let index = 0;

    return new ReadableStream({
        async pull(controller) {
            if (index < data.length) {
                controller.enqueue(encoder.encode(data[index]));
                index++;
            } else {
                controller.close();
            }
        }
    });
}

describe("Streaming Utilities", () => {
    describe("isNodeEnvironment", () => {
        it("should return true in Node.js environment", () => {
            expect(isNodeEnvironment()).toBe(true);
        });
    });

    describe("parseNDJSONStream (Node.js)", () => {
        it("should parse single line NDJSON", async () => {
            const ndjson = '{"result":{"object":"document:1"}}\n';
            const stream = Readable.from([ndjson]);

            const results: any[] = [];
            for await (const item of parseNDJSONStream(stream)) {
                results.push(item);
            }

            expect(results).toHaveLength(1);
            expect(results[0]).toEqual({ result: { object: "document:1" } });
        });

        it("should parse multiple line NDJSON", async () => {
            const ndjson = '{"result":{"object":"document:1"}}\n{"result":{"object":"document:2"}}\n{"result":{"object":"document:3"}}\n';
            const stream = Readable.from([ndjson]);

            const results: any[] = [];
            for await (const item of parseNDJSONStream(stream)) {
                results.push(item);
            }

            expect(results).toHaveLength(3);
            expect(results[0]).toEqual({ result: { object: "document:1" } });
            expect(results[1]).toEqual({ result: { object: "document:2" } });
            expect(results[2]).toEqual({ result: { object: "document:3" } });
        });

        it("should handle chunked data across multiple reads", async () => {
            // Simulate data coming in chunks that split JSON objects mid-line
            const chunks = [
                '{"result":{"object":"document:1"}}\n{"res',
                'ult":{"object":"document:2"}}\n'
            ];

            const stream = Readable.from(chunks);

            const results: any[] = [];
            for await (const item of parseNDJSONStream(stream)) {
                results.push(item);
            }

            expect(results).toHaveLength(2);
            expect(results[0]).toEqual({ result: { object: "document:1" } });
            expect(results[1]).toEqual({ result: { object: "document:2" } });
        });

        it("should handle empty lines", async () => {
            const ndjson = '{"result":{"object":"document:1"}}\n\n{"result":{"object":"document:2"}}\n';
            const stream = Readable.from([ndjson]);

            const results: any[] = [];
            for await (const item of parseNDJSONStream(stream)) {
                results.push(item);
            }

            expect(results).toHaveLength(2);
        });

        it("should skip invalid JSON lines", async () => {
            const consoleWarnSpy = jest.spyOn(console, "warn").mockImplementation();

            const ndjson = '{"result":{"object":"document:1"}}\ninvalid json\n{"result":{"object":"document:2"}}\n';
            const stream = Readable.from([ndjson]);

            const results: any[] = [];
            for await (const item of parseNDJSONStream(stream)) {
                results.push(item);
            }

            expect(results).toHaveLength(2);
            expect(results[0]).toEqual({ result: { object: "document:1" } });
            expect(results[1]).toEqual({ result: { object: "document:2" } });
            expect(consoleWarnSpy).toHaveBeenCalled();

            consoleWarnSpy.mockRestore();
        });
    });

    describe("parseNDJSONReadableStream (Browser)", () => {
        it("should parse single line NDJSON", async () => {
            const ndjson = '{"result":{"object":"document:1"}}\n';
            const stream = createMockReadableStream([ndjson]);

            const results: any[] = [];
            for await (const item of parseNDJSONReadableStream(stream)) {
                results.push(item);
            }

            expect(results).toHaveLength(1);
            expect(results[0]).toEqual({ result: { object: "document:1" } });
        });

        it("should parse multiple line NDJSON", async () => {
            const stream = createMockReadableStream([
                '{"result":{"object":"document:1"}}\n',
                '{"result":{"object":"document:2"}}\n',
                '{"result":{"object":"document:3"}}\n'
            ]);

            const results: any[] = [];
            for await (const item of parseNDJSONReadableStream(stream)) {
                results.push(item);
            }

            expect(results).toHaveLength(3);
            expect(results[0]).toEqual({ result: { object: "document:1" } });
            expect(results[1]).toEqual({ result: { object: "document:2" } });
            expect(results[2]).toEqual({ result: { object: "document:3" } });
        });

        it("should handle chunked data across multiple reads", async () => {
            // Simulate data coming in chunks that split JSON objects mid-line
            const stream = createMockReadableStream([
                '{"result":{"object":"document:1"}}\n{"res',
                'ult":{"object":"document:2"}}\n'
            ]);

            const results: any[] = [];
            for await (const item of parseNDJSONReadableStream(stream)) {
                results.push(item);
            }

            expect(results).toHaveLength(2);
            expect(results[0]).toEqual({ result: { object: "document:1" } });
            expect(results[1]).toEqual({ result: { object: "document:2" } });
        });

        it("should handle empty lines", async () => {
            const stream = createMockReadableStream([
                '{"result":{"object":"document:1"}}\n\n{"result":{"object":"document:2"}}\n'
            ]);

            const results: any[] = [];
            for await (const item of parseNDJSONReadableStream(stream)) {
                results.push(item);
            }

            expect(results).toHaveLength(2);
        });

        it("should skip invalid JSON lines", async () => {
            const consoleWarnSpy = jest.spyOn(console, "warn").mockImplementation();

            const stream = createMockReadableStream([
                '{"result":{"object":"document:1"}}\ninvalid json\n{"result":{"object":"document:2"}}\n'
            ]);

            const results: any[] = [];
            for await (const item of parseNDJSONReadableStream(stream)) {
                results.push(item);
            }

            expect(results).toHaveLength(2);
            expect(results[0]).toEqual({ result: { object: "document:1" } });
            expect(results[1]).toEqual({ result: { object: "document:2" } });
            expect(consoleWarnSpy).toHaveBeenCalled();

            consoleWarnSpy.mockRestore();
        });

        it("should release the reader lock on completion", async () => {
            const stream = createMockReadableStream(['{"result":{"object":"document:1"}}\n']);

            const results: any[] = [];
            for await (const item of parseNDJSONReadableStream(stream)) {
                results.push(item);
            }

            expect(results).toHaveLength(1);
            // If reader lock wasn't released, this would throw
            expect(() => stream.getReader()).not.toThrow();
        });

        it("should handle final buffer with incomplete data gracefully", async () => {
            const consoleWarnSpy = jest.spyOn(console, "warn").mockImplementation();

            const stream = createMockReadableStream([
                '{"result":{"object":"document:1"}}\n{"incomplete'
            ]);

            const results: any[] = [];
            for await (const item of parseNDJSONReadableStream(stream)) {
                results.push(item);
            }

            expect(results).toHaveLength(1);
            expect(results[0]).toEqual({ result: { object: "document:1" } });
            expect(consoleWarnSpy).toHaveBeenCalled();

            consoleWarnSpy.mockRestore();
        });
    });

    describe("createFetchError", () => {
        it("should create FgaApiValidationError for 400 status", async () => {
            const mockResponse = {
                status: 400,
                statusText: "Bad Request",
                headers: new Map([["content-type", "application/json"]]),
                json: async () => ({ code: "validation_error", message: "Invalid request" })
            } as unknown as Response;

            const error = await createFetchError(mockResponse, "http://localhost/test", {});

            expect(error.name).toBe("FgaApiValidationError");
        });

        it("should create FgaApiAuthenticationError for 401 status", async () => {
            const mockResponse = {
                status: 401,
                statusText: "Unauthorized",
                headers: new Map(),
                json: async () => ({ message: "Unauthorized" })
            } as unknown as Response;

            const error = await createFetchError(mockResponse, "http://localhost/test", {});

            expect(error.name).toBe("FgaApiAuthenticationError");
        });

        it("should create FgaApiRateLimitExceededError for 429 status", async () => {
            const mockResponse = {
                status: 429,
                statusText: "Too Many Requests",
                headers: new Map(),
                json: async () => ({ message: "Rate limited" })
            } as unknown as Response;

            const error = await createFetchError(mockResponse, "http://localhost/test", {});

            expect(error.name).toBe("FgaApiRateLimitExceededError");
        });

        it("should create FgaApiInternalError for 500 status", async () => {
            const mockResponse = {
                status: 500,
                statusText: "Internal Server Error",
                headers: new Map(),
                json: async () => ({ message: "Server error" })
            } as unknown as Response;

            const error = await createFetchError(mockResponse, "http://localhost/test", {});

            expect(error.name).toBe("FgaApiInternalError");
        });
    });

    describe("attemptFetchRequest", () => {
        it("should return response on success", async () => {
            const mockFetch = jest.fn().mockResolvedValue({
                ok: true,
                body: createMockReadableStream(['{"result":{"object":"document:1"}}\n']),
                headers: new Map()
            });
            global.fetch = mockFetch as any;

            const response = await attemptFetchRequest(
                "http://localhost/test",
                { method: "POST" },
                {},
                { maxRetry: 3, minWaitInMs: 10 }
            );

            expect(response.ok).toBe(true);
            expect(mockFetch).toHaveBeenCalledTimes(1);
        });

        it("should retry on 429 and eventually succeed", async () => {
            const mockFetch = jest.fn()
                .mockResolvedValueOnce({
                    ok: false,
                    status: 429,
                    statusText: "Too Many Requests",
                    headers: new Map(),
                    json: async () => ({ message: "Rate limited" })
                })
                .mockResolvedValueOnce({
                    ok: true,
                    body: createMockReadableStream(['{"result":{"object":"document:1"}}\n']),
                    headers: new Map()
                });
            global.fetch = mockFetch as any;

            const response = await attemptFetchRequest(
                "http://localhost/test",
                { method: "POST" },
                {},
                { maxRetry: 3, minWaitInMs: 10 }
            );

            expect(response.ok).toBe(true);
            expect(mockFetch).toHaveBeenCalledTimes(2);
        });

        it("should throw FgaApiValidationError on 400 without retry", async () => {
            const mockFetch = jest.fn().mockResolvedValue({
                ok: false,
                status: 400,
                statusText: "Bad Request",
                headers: new Map(),
                json: async () => ({ code: "validation_error", message: "Invalid" })
            });
            global.fetch = mockFetch as any;

            await expect(
                attemptFetchRequest(
                    "http://localhost/test",
                    { method: "POST" },
                    {},
                    { maxRetry: 3, minWaitInMs: 10 }
                )
            ).rejects.toThrow();

            expect(mockFetch).toHaveBeenCalledTimes(1); // Should not retry on 400
        });
    });
});

