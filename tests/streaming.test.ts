/**
 * JavaScript and Node.js SDK for OpenFGA
 *
 * API version: 1.x
 * Website: https://openfga.dev
 * Documentation: https://openfga.dev/docs
 * Support: https://openfga.dev/community
 * License: [Apache-2.0](https://github.com/openfga/js-sdk/blob/main/LICENSE)
 *
 * NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 */


import { Readable } from "node:stream";
import { EventEmitter } from "node:events";
import { parseNDJSONStream } from "../streaming";

describe("Streaming Utilities", () => {
    describe("parseNDJSONStream (Node.js)", () => {
        it("should parse single line NDJSON", async () => {
            const ndjson = '{"result":{"object":"document:1"}}\n';
            const stream = Readable.from([ndjson]);

            const results: any[] = [];
            for await (const item of parseNDJSONStream(stream)) {
                results.push(item);
            }

            expect(results).toHaveLength(1);
            expect(results[0]).toEqual({ result: { object: "document:1" } });
        });

        it("should parse multiple line NDJSON", async () => {
            const ndjson = '{"result":{"object":"document:1"}}\n{"result":{"object":"document:2"}}\n{"result":{"object":"document:3"}}\n';
            const stream = Readable.from([ndjson]);

            const results: any[] = [];
            for await (const item of parseNDJSONStream(stream)) {
                results.push(item);
            }

            expect(results).toHaveLength(3);
            expect(results[0]).toEqual({ result: { object: "document:1" } });
            expect(results[1]).toEqual({ result: { object: "document:2" } });
            expect(results[2]).toEqual({ result: { object: "document:3" } });
        });

        it("should handle chunked data across multiple reads", async () => {
            // Simulate data coming in chunks that split JSON objects mid-line
            const chunks = [
                '{"result":{"object":"document:1"}}\n{"res',
                'ult":{"object":"document:2"}}\n'
            ];

            const stream = Readable.from(chunks);

            const results: any[] = [];
            for await (const item of parseNDJSONStream(stream)) {
                results.push(item);
            }

            expect(results).toHaveLength(2);
            expect(results[0]).toEqual({ result: { object: "document:1" } });
            expect(results[1]).toEqual({ result: { object: "document:2" } });
        });

        it("should handle empty lines", async () => {
            const ndjson = '{"result":{"object":"document:1"}}\n\n{"result":{"object":"document:2"}}\n';
            const stream = Readable.from([ndjson]);

            const results: any[] = [];
            for await (const item of parseNDJSONStream(stream)) {
                results.push(item);
            }

            expect(results).toHaveLength(2);
        });

        it("should skip invalid JSON lines", async () => {
            const consoleWarnSpy = jest.spyOn(console, "warn").mockImplementation();

            const ndjson = '{"result":{"object":"document:1"}}\ninvalid json\n{"result":{"object":"document:2"}}\n';
            const stream = Readable.from([ndjson]);

            const results: any[] = [];
            for await (const item of parseNDJSONStream(stream)) {
                results.push(item);
            }

            expect(results).toHaveLength(2);
            expect(results[0]).toEqual({ result: { object: "document:1" } });
            expect(results[1]).toEqual({ result: { object: "document:2" } });
            expect(consoleWarnSpy).toHaveBeenCalled();

            consoleWarnSpy.mockRestore();
        });

        it("should parse when Readable emits Buffer chunks", async () => {
            const ndjson = Buffer.from('{"a":1}\n{"b":2}\n');
            const stream = Readable.from([ndjson]);

            const out: any[] = [];
            for await (const item of parseNDJSONStream(stream)) {
                out.push(item);
            }
            expect(out).toEqual([{ a: 1 }, { b: 2 }]);
        });

        it("should parse last JSON without trailing newline", async () => {
            const stream = Readable.from(['{"a":1}\n{"b":2}']);

            const out: any[] = [];
            for await (const item of parseNDJSONStream(stream)) {
                out.push(item);
            }
            expect(out).toEqual([{ a: 1 }, { b: 2 }]);
        });

        it("should skip invalid final JSON buffer and warn", async () => {
            const warn = jest.spyOn(console, "warn").mockImplementation();
            const stream = Readable.from(['{"a":1}\n{"b":']);

            const out: any[] = [];
            for await (const item of parseNDJSONStream(stream)) {
                out.push(item);
            }
            expect(out).toEqual([{ a: 1 }]);
            expect(warn).toHaveBeenCalled();
            warn.mockRestore();
        });

        it("should parse when given a string input", async () => {
            const input = '{"a":1}\n{"b":2}\n';
            const out: any[] = [];
            for await (const item of parseNDJSONStream(input as any)) {
                out.push(item);
            }
            expect(out).toEqual([{ a: 1 }, { b: 2 }]);
        });

        it("should parse when given a Buffer input", async () => {
            const input = Buffer.from('{"a":1}\n{"b":2}\n');
            const out: any[] = [];
            for await (const item of parseNDJSONStream(input as any)) {
                out.push(item);
            }
            expect(out).toEqual([{ a: 1 }, { b: 2 }]);
        });

        it("should accept async iterable that yields Uint8Array", async () => {
            const src = {
                [Symbol.asyncIterator]: async function* () {
                    yield new TextEncoder().encode('{"a":1}\n{"b":2}\n');
                }
            } as any;

            const out: any[] = [];
            for await (const item of parseNDJSONStream(src)) {
                out.push(item);
            }
            expect(out).toEqual([{ a: 1 }, { b: 2 }]);
        });

        it("should reject pending iteration when classic emitter errors", async () => {
            const emitter = new EventEmitter() as any;
            const gen = parseNDJSONStream(emitter);

            const firstPromise = gen.next();
            emitter.emit("data", '{"a":1}\n');
            const first = await firstPromise;
            expect(first.value).toEqual({ a: 1 });

            const pendingNext = gen.next();
            emitter.emit("error", new Error("boom"));

            // Pending next should now reject with the error
            await expect(pendingNext).rejects.toThrow("boom");

            // After error, iterator is exhausted (standard async iterator behavior)
            await expect(gen.next()).resolves.toEqual({ value: undefined, done: true });
        });

        it("should clean up listeners on early cancellation", async () => {
            const emitter = new EventEmitter() as any;
            const gen = parseNDJSONStream(emitter);

            const p = gen.next();
            emitter.emit("data", '{"a":1}\n');
            const first = await p;
            expect(first.value).toEqual({ a: 1 });

            await gen.return(undefined as any);
            expect(emitter.listenerCount("data")).toBe(0);
            expect(emitter.listenerCount("end")).toBe(0);
            expect(emitter.listenerCount("error")).toBe(0);
        });

        it("should read from buffered queue when data exceeds pending resolvers", async () => {
            const emitter = new EventEmitter() as any;
            const gen = parseNDJSONStream(emitter);

            // Start consumption so listeners are attached and a pending resolver exists
            const firstPromise = gen.next();

            // First chunk fulfills the pending resolver
            emitter.emit("data", '{"x":1}\n');
            const first = await firstPromise;
            expect(first).toEqual({ value: { x: 1 }, done: false });

            // Emit another chunk before requesting next; it should be queued
            emitter.emit("data", '{"y":2}\n');

            // Next pull should be served from the buffered queue path
            const second = await gen.next();
            expect(second).toEqual({ value: { y: 2 }, done: false });

            // end stream to complete
            emitter.emit("end");
            const done = await gen.next();
            expect(done).toEqual({ value: undefined, done: true });
        });

        it("should resolve pending next to done when end occurs", async () => {
            const emitter = new EventEmitter() as any;
            const gen = parseNDJSONStream(emitter);

            const pending = gen.next();
            emitter.emit("end");

            await expect(pending).resolves.toEqual({ value: undefined, done: true });
            await expect(gen.next()).resolves.toEqual({ value: undefined, done: true });
        });

        it("should cleanup and reject on iterator throw", async () => {
            const emitter = new EventEmitter() as any;
            const gen = parseNDJSONStream(emitter);

            const thrown = gen.throw(new Error("stop"));
            await expect(thrown).rejects.toThrow("stop");

            expect(emitter.listenerCount("data")).toBe(0);
            expect(emitter.listenerCount("end")).toBe(0);
            expect(emitter.listenerCount("error")).toBe(0);
        });

        it("should warn on invalid JSON line in string input path", async () => {
            const warn = jest.spyOn(console, "warn").mockImplementation();
            const input = '{"a":1}\nnot json\n{"b":2}\n';

            const out: any[] = [];
            for await (const item of parseNDJSONStream(input as any)) {
                out.push(item);
            }
            expect(out).toEqual([{ a: 1 }, { b: 2 }]);
            expect(warn).toHaveBeenCalled();
            warn.mockRestore();
        });
    });
});