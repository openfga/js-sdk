/**
 * JavaScript and Node.js SDK for OpenFGA
 *
 * API version: 1.x
 * Website: https://openfga.dev
 * Documentation: https://openfga.dev/docs
 * Support: https://openfga.dev/community
 * License: [Apache-2.0](https://github.com/openfga/js-sdk/blob/main/LICENSE)
 *
 * NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 */


import globalAxios, { AxiosInstance } from "axios";
import * as jose from "jose";

import { assertParamExists, isWellFormedUriString } from "../validation";
import { FgaApiAuthenticationError, FgaApiError, FgaValidationError } from "../errors";
import { attemptHttpRequest } from "../common";
import { AuthCredentialsConfig, PrivateKeyJWTConfig, ClientCredentialsConfig, ClientSecretConfig, CredentialsMethod } from "./types";
import { TelemetryAttributes } from "../telemetry/attributes";
import { TelemetryCounters } from "../telemetry/counters";
import { TelemetryConfiguration } from "../telemetry/configuration";
import { randomUUID } from "crypto";

interface ClientSecretRequest {
  client_id: string;
  client_secret: string;
  audience: string;
  grant_type: "client_credentials";
}

interface ClientAssertionRequest {
  client_id: string;
  client_assertion: string;
  client_assertion_type: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer";
  audience: string;
}

const HTTP_SCHEME = "http://";
const HTTPS_SCHEME = "https://";

export const DEFAULT_TOKEN_ENDPOINT_PATH = "oauth/token";

export class Credentials {
  private accessToken?: string;
  private accessTokenExpiryDate?: Date;
  private refreshAccessTokenPromise?: Promise<string | undefined>;

  public static init(configuration: { credentials: AuthCredentialsConfig, telemetry: TelemetryConfiguration, baseOptions?: any }, axios: AxiosInstance = globalAxios): Credentials {
    return new Credentials(configuration.credentials, axios, configuration.telemetry, configuration.baseOptions);
  }

  public constructor(private authConfig: AuthCredentialsConfig, private axios: AxiosInstance = globalAxios, private telemetryConfig: TelemetryConfiguration, private baseOptions?: any) {
    this.initConfig();
    this.isValid();
  }

  /**
   * Sets the default config values
   * @private
   */
  private initConfig() {
    switch (this.authConfig?.method) {
    case CredentialsMethod.ApiToken:

      if (this.authConfig.config) {
        if (!this.authConfig.config.headerName) {
          this.authConfig.config.headerName = "Authorization";
        }
        if (!this.authConfig.config.headerValuePrefix) {
          this.authConfig.config.headerValuePrefix = "Bearer";
        }
      }
      break;
    case CredentialsMethod.None:
    default:
      break;
    }
  }

  /**
   *
   * @throws {FgaValidationError}
   */
  public isValid(): void {
    const { authConfig } = this;
    switch (authConfig?.method) {
    case CredentialsMethod.None:
      break;
    case CredentialsMethod.ApiToken:
      assertParamExists("Credentials", "config.token", authConfig.config?.token);
      assertParamExists("Credentials", "config.headerName", authConfig.config?.headerName);
      assertParamExists("Credentials", "config.headerName", authConfig.config?.headerName);
      break;
    case CredentialsMethod.ClientCredentials: {
      assertParamExists("Credentials", "config.clientId", authConfig.config?.clientId);
      assertParamExists("Credentials", "config.apiTokenIssuer", authConfig.config?.apiTokenIssuer);
      assertParamExists("Credentials", "config.apiAudience", authConfig.config?.apiAudience);
      assertParamExists("Credentials", "config.clientSecret or config.clientAssertionSigningKey", (authConfig.config as ClientSecretConfig).clientSecret || (authConfig.config as PrivateKeyJWTConfig).clientAssertionSigningKey);

      const normalizedApiTokenIssuer = this.normalizeApiTokenIssuer(authConfig.config?.apiTokenIssuer);
      if (!isWellFormedUriString(normalizedApiTokenIssuer)) {
        throw new FgaValidationError(
          `Configuration.apiTokenIssuer does not form a valid URI (${normalizedApiTokenIssuer})`);
      }
    }
      break;
    }
  }

  /**
   * Get access token, request a new one if not cached or expired
   * @return string
   */
  public async getAccessTokenHeader(): Promise<{ name: string; value: string } | undefined> {
    const accessTokenValue = await this.getAccessTokenValue();
    switch (this.authConfig?.method) {
    case CredentialsMethod.None:
      return;
    case CredentialsMethod.ApiToken:
      return {
        name: this.authConfig.config.headerName,
        value: `${this.authConfig.config.headerValuePrefix ? `${this.authConfig.config.headerValuePrefix} ` : ""}${accessTokenValue}`
      };
    case CredentialsMethod.ClientCredentials:
      return {
        name: "Authorization",
        value: `Bearer ${accessTokenValue}`
      };
    }
  }

  private async getAccessTokenValue(): Promise<string | undefined> {
    switch (this.authConfig?.method) {
    case CredentialsMethod.None:
      return;
    case CredentialsMethod.ApiToken:
      return this.authConfig.config.token;
    case CredentialsMethod.ClientCredentials:
      if (this.accessToken && (!this.accessTokenExpiryDate || this.accessTokenExpiryDate > new Date())) {
        return this.accessToken;
      }

      if (!this.refreshAccessTokenPromise) {
        this.refreshAccessTokenPromise = this.refreshAccessToken().finally(() => {
          this.refreshAccessTokenPromise = undefined;
        });
      }

      return this.refreshAccessTokenPromise;
    }
  }

  /**
   * Normalize API token issuer URL by ensuring it has a scheme
   * @private
   * @param apiTokenIssuer
   * @return string The normalized API token issuer URL
   */
  private normalizeApiTokenIssuer(apiTokenIssuer: string): string {
    if (apiTokenIssuer.startsWith(HTTP_SCHEME) || apiTokenIssuer.startsWith(HTTPS_SCHEME)) {
      return apiTokenIssuer;
    }
    return `${HTTPS_SCHEME}${apiTokenIssuer}`;
  }

  /**
   * Constructs the token endpoint URL from the provided API token issuer.
   * @private
   * @param apiTokenIssuer
   * @return string The constructed token endpoint URL if valid, otherwise throws an error
   * @throws {FgaValidationError} If the API token issuer URL is invalid
   */
  private buildApiTokenUrl(apiTokenIssuer: string): string {
    const normalizedApiTokenIssuer = this.normalizeApiTokenIssuer(apiTokenIssuer);

    try {
      const url = new URL(normalizedApiTokenIssuer);
      if (!url.pathname || url.pathname.match(/^\/+$/)) {
        url.pathname = `/${DEFAULT_TOKEN_ENDPOINT_PATH}`;
      }
      return url.toString(); // Query params are preserved in the URL
    } catch {
      throw new FgaValidationError(`Invalid API token issuer URL: ${normalizedApiTokenIssuer}`);
    }
  }

  /**
   * Request new access token
   * @return string
   */
  private async refreshAccessToken() {
    const clientCredentials = (this.authConfig as { method: CredentialsMethod.ClientCredentials; config: ClientCredentialsConfig })?.config;
    const url = this.buildApiTokenUrl(clientCredentials.apiTokenIssuer);
    const credentialsPayload = await this.buildClientAuthenticationPayload();

    try {
      const wrappedResponse = await attemptHttpRequest<ClientSecretRequest|ClientAssertionRequest, {
        access_token: string,
        expires_in: number,
      }>({
        url,
        method: "POST",
        data: credentialsPayload,
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        }
      }, {
        maxRetry: 3,
        minWaitInMs: 100,
      }, this.axios);

      const response = wrappedResponse?.response;
      if (response) {
        this.accessToken = response.data.access_token;
        this.accessTokenExpiryDate = new Date(Date.now() + response.data.expires_in * 1000);
      }

      if (this.telemetryConfig?.metrics?.counterCredentialsRequest?.attributes) {

        let attributes = {};

        attributes = TelemetryAttributes.fromRequest({
          userAgent: this.baseOptions?.headers["User-Agent"],
          fgaMethod: "TokenExchange",
          url,
          resendCount: wrappedResponse?.retries,
          httpMethod: "POST",
          credentials: clientCredentials,
          start: performance.now(),
          attributes,
        });

        attributes = TelemetryAttributes.fromResponse({
          response,
          attributes,
        });

        attributes = TelemetryAttributes.prepare(attributes, this.telemetryConfig.metrics?.counterCredentialsRequest?.attributes);
        this.telemetryConfig.recorder.counter(TelemetryCounters.credentialsRequest, 1, attributes);
      }

      return this.accessToken;
    } catch (err: unknown) {
      if (err instanceof FgaApiError) {
        (err as any).constructor = FgaApiAuthenticationError;
        (err as any).name = "FgaApiAuthenticationError";
        (err as any).clientId = clientCredentials.clientId;
        (err as any).audience = clientCredentials.apiAudience;
        (err as any).grantType = "client_credentials";
      }

      throw err;
    }
  }

  private async buildClientAuthenticationPayload(): Promise<ClientSecretRequest|ClientAssertionRequest> {
    if (this.authConfig?.method !== CredentialsMethod.ClientCredentials) {
      throw new FgaValidationError("Credentials method is not set to ClientCredentials");
    }

    const config = this.authConfig.config;
    if ((config as PrivateKeyJWTConfig).clientAssertionSigningKey) {
      const alg = (config as PrivateKeyJWTConfig).clientAssertionSigningAlgorithm || "RS256";
      const privateKey = await jose.importPKCS8((config as PrivateKeyJWTConfig).clientAssertionSigningKey, alg);
      const audienceIssuer = this.normalizeApiTokenIssuer(config.apiTokenIssuer);
      const assertion = await new jose.SignJWT({})
        .setProtectedHeader({ alg })
        .setIssuedAt()
        .setSubject(config.clientId)
        .setJti(randomUUID())
        .setIssuer(config.clientId)
        .setAudience(`${audienceIssuer}/`) // Trailing slash is required by the OAuth 2.0 specification
        .setExpirationTime("2m")
        .sign(privateKey);
      return {
        ...config.customClaims,
        client_id: (config as PrivateKeyJWTConfig).clientId,
        client_assertion: assertion,
        audience: config.apiAudience,
        client_assertion_type: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
        grant_type: "client_credentials",
      } as ClientAssertionRequest;
    } else if ((config as ClientSecretConfig).clientSecret) {
      return {
        ...config.customClaims,
        client_id: (config as ClientSecretConfig).clientId,
        client_secret: (config as ClientSecretConfig).clientSecret,
        audience: (config as ClientSecretConfig).apiAudience,
        grant_type: "client_credentials",
      };
    }

    throw new FgaValidationError("Credentials method is set to ClientCredentials, but no clientSecret or clientAssertionSigningKey is provided");
  }
}
