/* tslint:disable */
/* eslint-disable */
/**
 * JavaScript and Node.js SDK for OpenFGA
 *
 * API version: 0.1
 * Website: https://openfga.dev
 * Documentation: https://openfga.dev/docs
 * Support: https://discord.gg/8naAwJfWN6
 *
 * NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 */


import { AxiosResponse, AxiosStatic } from 'axios';

import { Configuration } from "./configuration";
import {
OpenFgaApiError,
OpenFgaApiInternalError,
OpenFgaAuthenticationError,
OpenFgaApiNotFoundError,
OpenFgaApiRateLimitExceededError,
OpenFgaApiValidationError,
OpenFgaError
} from "./errors";

/**
 *
 * @export
 */
export const DUMMY_BASE_URL = 'https://example.com';

/**
 *
 * @export
 * @interface RequestArgs
 */
export interface RequestArgs {
    url: string;
    options: any;
}


/**
 *
 * @export
 */
export const setBearerAuthToObject = async function (object: any, configuration: Configuration) {
    const accessToken = await configuration.getAccessToken();
    if (accessToken) {
        object["Authorization"] = "Bearer " + accessToken;
    }
}

/**
 *
 * @export
 */
export const setSearchParams = function (url: URL, ...objects: any[]) {
    const searchParams = new URLSearchParams(url.search);
    for (const object of objects) {
        for (const key in object) {
            if (Array.isArray(object[key])) {
                searchParams.delete(key);
                for (const item of object[key]) {
                    searchParams.append(key, item);
                }
            } else {
                searchParams.set(key, object[key]);
            }
        }
    }
    url.search = searchParams.toString();
}

/**
 *
 * @export
 */
export const serializeDataIfNeeded = function (value: any, requestOptions: any, configuration: Configuration) {
    const nonString = typeof value !== 'string';
    const needsSerialization = nonString && configuration && configuration.isJsonMime
        ? configuration.isJsonMime(requestOptions.headers['Content-Type'])
        : nonString;
    return needsSerialization
        ? JSON.stringify(value !== undefined ? value : {})
        : (value || "");
}

/**
 *
 * @export
 */
export const toPathString = function (url: URL) {
    return url.pathname + url.search + url.hash
}

type ObjectOrVoid = {} | void;

export type CallResult<T extends ObjectOrVoid> = T & {
    $response: AxiosResponse<T>
};

export type PromiseResult<T extends ObjectOrVoid> = Promise<CallResult<T>>;

function randomTime(loopCount: number, minWaitInMs: number): number {
    const min = Math.ceil(2 ** loopCount * minWaitInMs);
    const max = Math.ceil(2 ** (loopCount + 1) * minWaitInMs);
    return Math.floor(Math.random() * (max - min) + min); //The maximum is exclusive and the minimum is inclusive
}

/**
 * creates an axios request function
 */
export const createRequestFunction = function (axiosArgs: RequestArgs, globalAxios: AxiosStatic, configuration: Configuration) {
    configuration.isValid();

    const retryParams = axiosArgs.options?.retryParams ? axiosArgs.options?.retryParams : configuration.retryParams;
    const maxRetry:number = retryParams ? retryParams.maxRetry : 0;
    const minWaitInMs:number = retryParams ? retryParams.minWaitInMs : 0;
    return async (axios: AxiosStatic = globalAxios) : PromiseResult<any> => {
        await setBearerAuthToObject(axiosArgs.options.headers, configuration);
        for (let i = 0; i < maxRetry + 1; i++) {
            try {
                const axiosRequestArgs = {...axiosArgs.options, url: configuration.getBasePath() + axiosArgs.url};
                const response = await axios.request(axiosRequestArgs);
                const data = typeof response.data === 'undefined' ? {} : response.data;
                const result: CallResult<any> = { ...data };
                Object.defineProperty(result, '$response', {
                    enumerable: false,
                    writable: false,
                    value: response
                });
                return result;
            } catch (err: unknown) {
                if (!axios.isAxiosError(err) || !err.response?.status) {
                    throw new OpenFgaError(err as Error);
                }
                if (err.response?.status === 400 || err.response?.status === 422) {
                    throw new OpenFgaApiValidationError(err);
                } else if (err.response?.status === 401 || err.response?.status === 403) {
                    throw new OpenFgaAuthenticationError(err);
                } else if (err.response?.status === 404) {
                    throw new OpenFgaApiNotFoundError(err);
                } else if (err.response?.status === 429) {
                    if (i >= maxRetry) {
                        // We have reached the max retry limit
                        // Thus, we have no choice but to throw
                        throw new OpenFgaApiRateLimitExceededError(err);
                    }
                    await new Promise(r => setTimeout(r, randomTime(i, minWaitInMs)));
                } else if (err.response?.status >= 500) {
                    throw new OpenFgaApiInternalError(err);
                } else {
                    throw new OpenFgaApiError(err);
                }
            }
        }
    };
}
